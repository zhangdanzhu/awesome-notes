
* [C++ Basic Notes](#c-basic-notes)
	* [Basic Workflow](#basic-workflow)
		* [初始化与回收](#初始化与回收)
	* [变量、类型与函数](#变量类型与函数)
		* [变量](#变量)
		* [指针](#指针)
		* [类型](#类型)
			* [volatile](#volatile)
			* [reference (引用类型)](#reference-引用类型)
				* [性质](#性质)
				* [作为函数参数](#作为函数参数)
				* [特性](#特性)
		* [Expression (表达式)](#expression-表达式)
		* [函数](#函数)
			* [参数的默认值(defalut)](#参数的默认值defalut)
	* [类](#类)
		* [访问控制权限](#访问控制权限)
		* [派生控制权限](#派生控制权限)
		* [构造函数](#构造函数)
			* [调用形式](#调用形式)
			* [功能](#功能)
		* [析构函数](#析构函数)
		* [`new` 与 `delete`/`delete []`](#new-与-deletedelete-)
		* [成员指针 与 指针成员](#成员指针-与-指针成员)
			* [成员指针 - 指向成员的指针](#成员指针---指向成员的指针)
			* [定义含指针成员(成员是个指针)的类](#定义含指针成员成员是个指针的类)
		* [函数成员](#函数成员)
			* [const/volatile 关键字修饰](#constvolatile-关键字修饰)
		* [静态成员](#静态成员)
			* [静态数据成员](#静态数据成员)
			* [特性](#特性-1)
			* [定义](#定义)
			* [静态函数成员](#静态函数成员)
			* [引用形式](#引用形式)
			* [特性](#特性-2)
		* [友元](#友元)
			* [成员友元函数](#成员友元函数)
		* [虚函数](#虚函数)
			* [特性](#特性-3)
			* [功能](#功能-1)
			* [纯虚函数 与 抽象类](#纯虚函数-与-抽象类)
	* [作用域(Scope)](#作用域scope)
		* [面向过程的作用域](#面向过程的作用域)
		* [面向对象的作用域](#面向对象的作用域)
			* [命名空间(namespace)](#命名空间namespace)
	* [运算符重载](#运算符重载)
	* [模板](#模板)
		* [调用形式](#调用形式-1)
	* [异常](#异常)
		* [异常对象的析构](#异常对象的析构)
	* [Awesome Tips / Best Practice](#awesome-tips--best-practice)

# C++ Basic Notes

## Basic Workflow

### 初始化与回收
-   Treat global program as a object: 开工函数与收工函数
-   Normal Object: 构造函数与析构函数

## 变量、类型与函数

### 变量

const 变量 代替 #define 宏定义

### 指针 

-   只读指针可赋值为 普通对象地址
-   普通指针不可赋值为 只读对象地址

### 类型

#### volatile

表示可被其他线程/进程改变的变量.volatile 变量常作为全局变量,用于同步各进程.

```cpp
volatile int x;

x = 3;

if (4 == x) {
    cout << "X changed by other routines.";
}
```

#### reference (引用类型)

##### 性质

引用类型(&)实质上是一种语法糖,编译器将引用变量最终全部编译为指针变量

##### 作为函数参数

向函数传递引用类型实参时,若:

-   实参与形参类型不一致 
-   实参为(右)值表达式(常量)

则会生成一个内部匿名变量,用于函数调用.此时,对参数进行的操作将无法改变实参原有值,使得 call by reference 失效.

##### 特性

-   普通全局引用变量必须初始化(左值表达式)            `int &k = j++; // error`
-   引用变量不分配存储单元: 数组元素不能作为引用变量  `int &s[4];    // error`
-   引用变量的值按字节(指针/地址)编码: 位段不能被引用 `int &w = a.j; // error`
-   引用变量不能再次引用另一个引用变量                `int &&m = j;  // error`

### Expression (表达式)

左值表达式一定可作(右)值表达式,(右)值表达式不可作左值表达式

e.g 左值表达式: bar, ++i;
    (右)值表达式: 2, i++, y+2;

### 函数

#### 参数的默认值(defalut)

-   不能在 **函数原型声明** 与 **函数定义** 中 **同时** 定义参数的默认值,会产生默认值冲突
-   所有缺省参数必须位于参数列表右边
-   不能用前一个参数初始化后一个参数
-   当同时有 `int g(void)` `int g(int x = 1)` 时, 不能调用 g() (具有二义性)

```cpp
int bar(int x , int y = 5, int z = m(u,v));
int foo(int x, int y = x++);    // error
```

## 类

### 访问控制权限

public > protected > private + friend > private

### 派生控制权限

public 控制权限可产生 父类与子类. 父类指针可以直接指向子类对象,普通基类指针必须通过强制类型转换才能指向派生类对象.

### 构造函数

#### 调用形式

构造函数不可被显式调用(类前缀),必须隐式调用(省略类前缀)

#### 功能

-   只读成员、引用成员、对象成员只可在构造函数处**初始化**, 其他数据成员可在定义时初始化,也可在构造函数处**初始化**
-   构造函数体前: 初始化只读成员、引用成员、对象成员、其他数据成员, 初始化顺序以**定义顺序**为准, **无关构造函数体前出现顺序**
-   构造函数体内: 初始化其他数据成员(不可初始化只读成员、引用成员、对象成员)

```cpp
class Foo {
    const int b;
    int c, &d, e, f;
    String g, h;

public:
    // 初始化顺序: b, c, d, e, f, g, h
    Foo(int bar): d(c), c(bar), g(bar), b(bar), e(bar) {
        c += bar;
        f = bar;
    }
};
```

-   形式为 Foo:Foo(Foo &obj) 的构造函数,可使得对象作为实参传递时自动进行深拷贝复制

### 析构函数

-   析构函数即可显式调用,又可隐式调用
-   析构函数与全局 main 函数 没有重载函数

-   作用域结束时会自动调用析构函数
-   调用 exit/abort 时, 需手动调用析构函数释放资源

```cpp
String x("global");

int main(void) {
    short error = 0;
    String y("local");

    // set error flag
    switch (error) {
        case 0:
            return;
        case 1:
            y.~String();
            exit(1);
        default:
            x.~String();
            y.~String();
            abort();
    }

    return 0;
}
```

-   设置 **析构标志** 防止重复析构同一对象

```cpp
String::~String() {
    // check flag
    if (s == NULL) {
        return;
    }

    cout<<"Deconstruct:"<<s;

    free(s);

    // set flag
    s = NULL;
}
```

### `new` 与 `delete`/`delete []`

-   实例化有构造函数的类时,只能用 new, 不能用 malloc
-   回收有析构函数的类时,只能用 delete, 不能用 free
-   为普通指针变量分配/回收内存单元: 可用 malloc/new/free/delete

### 成员指针 与 指针成员

#### 成员指针 - 指向成员的指针

考虑到越界问题,成员指针不可移动

```cc
int A::*pi = &A::i;
```

#### 定义含指针成员(成员是个指针)的类

-   深拷贝构造函数: T(const T &)
-   深拷贝赋值运算函数: virtual T& operator=(const T &)
-   虚析构函数: virtual ~T()   
-   定义`T &p = *new T()`后, 使用`delete &p`释放内存
-   定义`T *p = new T()`后, 使用`delete p`释放内存

### 函数成员

#### const/volatile 关键字修饰

-   修饰函数成员隐含参数 - this 对象指针,表示不可修改/挥发对象
-   被修饰函数成员不能修改对象自身(即对象的**普通数据成员**), 可以修改对象的**静态**数据成员
-   构造函数/析构函数不可被 const/volatile 修饰

### 静态成员

#### 静态数据成员

#### 特性

-   静态数据成员脱离对象实例存在 `Person::totalNum`
-   静态数据成员存储单元不属于任何对象实例

#### 定义

-   不能在**构造函数/析构函数**中 创建/释放 静态数据成员的存储单元
-   在类体内声明静态数据成员, 在类体外定义并初始化静态数据成员  `List * List::head = NULL;`
-   局部类/union类不可定义静态数据成员

#### 静态函数成员

-   静态函数成员不含隐含参数 - this 对象指针
-   构造/析构/const/volatile函数(均有 this 对象指针)不能定义为静态函数成员

#### 引用形式

-   抽象类型 `List::sort()`
-   对象实例 `list.sort()`

#### 特性

-   只能直接修改静态数据成员
-   可以通过静态函数成员的函数参数,传入对象实例指针,从而间接修改非静态数据成员

### 友元

-   在重载函数中, (函数签名不一致的)未声明的函数只能访问类的共有成员
-   static/virtual 与 friend 不能共用

#### 成员友元函数

可在3处定义函数体:

-   函数定义处(本类)
-   定义友元处(它类)
-   类体外

### 虚函数

#### 特性

-   无限传递性: 派生类中原型相同的函数自动成为虚函数
-   具有隐式参数 - this 对象指针: 不能为静态函数成员
-   构造函数不能为虚函数,析构函数可以为虚函数

#### 功能

实现运行时多态. 最好将普通函数成员**全部**定义为 虚函数.

#### 纯虚函数 与 抽象类

-   纯虚函数具有虚函数的所有特性
-   具有纯虚函数的类自动成为抽象类

```cc
struct A {
    virtual void f1() = 0;
    virtual void f2() = 0;
};
```

## 作用域(Scope)

-   标识符的作用域越小,访问的优先级别越高
-   单目运算符 `::` 可访问全局符号  e.g `::process++ // 自加全局变量 process`

### 面向过程的作用域

-   作用于表达式内
-   作用于函数内
-   作用于程序文件内
-   作用于整个程序

### 面向对象的作用域

-   作用于**函数成员**内
-   作用于**类/派生类**内
-   作用于**基类**内
-   作用域**虚基类**内

#### 命名空间(namespace)

-   指定一个完全的命名空间时, 不会将任何标识符加入当前作用域. 可重新定义同名局部符号
-   指定一个命名空间的具体成员时, 会将成员符号加入当前作用域
-   可以为嵌套命名空间定义别名

```cpp
namespace ABCD = A::B::C;
```

## 运算符重载

|运算符|重载方式|
|:---------------:|:--------------------:|
|sizeof  .  .*  ::  ?:|不可重载|
|=  ->  ()  []|普通函数成员|
|new delete|静态函数成员 普通函数|
|其他运算符|普通函数成员 普通函数|

## 模板

### 调用形式

-   函数标签相同的覆盖函数
-   通过函数模板自动生成可匹配参数的实例函数
-   通过强制类型转换,调用已经手动生成的可匹配参数的实例函数
-   调用失败

## 异常

### 异常对象的析构

catch (const A *a) 形式

## Awesome Tips / Best Practice

*   普通函数成员 与 析构函数 全部定义为虚函数
*   不改变对象实例的函数 全部定义为 const 函数
*   被改变参数/返回值 全部定义为 引用类型
*   深拷贝(赋值)函数参数/返回值 全部定义为 引用类型
